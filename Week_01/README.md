# 学习笔记
## 数组
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。

数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，平均情况时间复杂度为 O(n)。

## 链表
链表更适合插入、删除操作频繁的场景，时间复杂度为 O(1)，查询的时间复杂度较高，时间复杂度为 O(n)。

## 跳表
在跳表中查询任意数据的时间复杂度是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。

跳表不能完全替代红黑树，是因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。但是跳表并没有一个现成的实现。

## 栈
从操作特性上来说，栈是一种「操作受限」的线性表。可以用数组或链表来实现栈。用数组实现的栈，称作顺序栈；用链表实现的栈，称作链式栈。入栈、出栈的时间复杂度都为 O(1)。

## 队列
队列最大的特点就是先进先出，主要的两个操作是入队和出队。用数组实现的叫顺序队列，用链表实现的叫链式队列。

## 024 两两交换链表中的节点
### 方法一：递归法
递归的思考方式为：直接推到末尾，然后倒序思考返回值的传递方向。

递归法：
1. 判断输入是否为空，或仅有一个节点
2. 设置双指针
3. 递归（返回值赋值给第一个指针）
4. 移动第二个指针
5. 返回值为第二个指针

### 方法二：遍历法
利用哨兵节点简化判断。

1. 设置哨兵节点
2. 进入循环遍历
3. 设置双指针
4. 交换指针所指节点顺序
5. 移动指针
6. 返回头节点（注意，这个头结点的变量）

## 141 环形链表
### 快慢指针法

1. 判断输入是否为空或仅有一个节点
2. 设置快慢指针
3. 进入循环，条件为快慢指针没有相遇
4. 判断快指针是否到达链表末尾，如到达则返回 False
5. 移动快慢指针
6. 相遇，终止循环，返回 True

## 142 环形链表 2
### 快慢指针法

和 141 是类似的，只不过多了环入口检测的步骤。

## 25 k 个一组翻转链表
### 方法一：尾插法

1. 设置哨兵节点和缝合指针
2. 设置哨兵节点指向头指针和片段左右指针初始化
3. 进入循环
4. 初始化计数器
5. 寻找 k 个元素的片段，设置右指针
6. 当计数器找到 k 个元素，进入循环
7. 设置双指针
8. 双指针改变链表指向
9. 退出循环后连接相邻的片段
10. 直到无法找到足够的 k 个元素，返回链表头

### 方法二：递归法
和方法一中一样，`pre` 指针在调整 k 个元素指向之前及之后，指向的都是小片段的头结点。

这里的，`head` 节点是方法一中的 `cur` 节点。

递归的思想还是，从后往前思考。每次递归的返回值都应该能和之前的步骤连续上。

1. 设置头结点
2. 设置计数器
3. 利用循环寻找小片段的尾节点
4. 当找到 k 个节点，进入递归，返回值为下个小片段的头结点
5. 进入循环，调整朝向
6. 出循环，将 `head` 调整为小片段的头结点
7. 返回头结点

